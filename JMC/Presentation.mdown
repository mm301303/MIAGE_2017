# Pourquoi git ? 

On va faire un très bref explicatif de la raison de l'existence de git avant de rentrer plus particulièrement dans comment ça fonctionne.

Tout d'abord le nom, ça veut dire plus ou moins "connard" en anglais, et c'est un qualificatif qu'on utilisera assez souvent dans la pratique pour désigner les noms d'utilisateurs qui sortent quand on fait un git blame. Mais ça aussi, on verra les commandes après.

Git et un logiciel assez simple dans son fonctionnement, il a été créé par Linus Torvals, le créateur de linux entre autres, avec l'objectif de créer un gestionnaire de version de fichier pour soutenir le projet linux, ce qui est le cas depuis 2005.
Le but d'un gestionnaire de version de fichier est de conserver différentes versions du code source d'un projet ainsi que les différences entre ces versions.

# Comment ça marche ?

Je vais essayer de décrire très généralement mais assez précisement pour entrer dans ma pratique le principe de fonctionnement de git en tant que gestionnaire de version décentralisé : 

Il faut concevoir un projet dans le système de fichier comme un arbre. 
Cet arbre contient l'arborescence du projet et les différents fichiers à un instant donné. 
On peut choisir à tout moment de prendre un instantané de cet arbre, et de le stocker dans un historique sur la machine locale : c'est l'action de commit. le commit est un objet qui est lié au commit parent, ce qui crée une arborescence chronologique pour chaque fichier. Le commit porte une version pour chacun des fichiers par l'intermédiaire d'une somme de contrôle : un nombre qui varie à chaque modification. Git n'intégrera a un commit que les fichiers dont ce nombre a varé depuis ce dernier commit. 

Il est alors possible de revenir à la version sauvegardée, mais cette version de l'arbre n'est pas accessible aux autres développeurs sur le projet. 
On peut alors push ses commits : c'est l'action de les envoyer sur le serveur distant, qui mettra à jour les fichiers impactés par les changemements, soit qui ont une somme de controle différente.
Un autre développeur du projet pourra alors pull les modifications pour voir la version modifiée apparaitre dans son arborescence locale.

A partir d'ici, il est facile d'imaginer que le deuxieme développeur ait modifié le même fichier au même endroit que le premier développeur : s'il commit ses changements, il devra faire la mise à jour du fichier à la main, c'est ce qu'on appelle un conflit, et c'est l'action de merge à la main. Le merge est normalement assuré automatiquement par got si personne n'a modifié au même moment les mêmes parties de code.

Pour faciliter le travail en groupe, il existe une notion de branche qui permet "d'isoler" le travail des différents acteurs sur les différentes fonctionnalités.
Ces branches portent chacune un historique parallèle les unes aux autres, peuvent être crées "sur" un commit, peuvent être lergées entre elles.
On utilise généralement une branche nommée master (la branche par défaut) ou release pour porter la version fonctionnelle d'un projet, cad qu'on y mettra que du code fonctionnel à destination de la production/client/prof.

# Partie technique : la théorie
 
Il n'est pas nécessaire pour travailler sur git de se servir couramment chaque commande et option de l'outil, mais seulement d'en connaitre le fonctionnement des principales.

Dans l'ordre d'utilisation (autant que possible), voici les commandes suffisantes pour se servir des fonctionnalités principales de l'outil :

***git init*** : cree le dossier caché .git qui contient l'historique des versions

***git clone*** :  permet de copier un répertoire git sur une machine locale (ainsi que l'adresse du serveur distant)

***git remote*** :  permet de connaitre et de set l'adresse du serveur distant

***git fetch*** : permet de charger l'état du serveur distant sur l'arbre local : c'est le git pull des branches

***git status*** :  permet de connaitre l'état des fichiers par rapport au dernier commit en local (modification, addition, suggestion de fichier à suivre)

***git add*** : permet d'ajouter un fichier à l'arbre local (lequel ne contient que les fichiers ajoutés de cette manière)

***git remov*** : supprime le fichier des arbres distant et local. Ne supprime pas le fichier dans l'arborescence

***git commit*** : enregistre l'état des fichiers ajoutés dans l'arbre local

***git push*** : permet d'envoyer un commit sur une branche de l'arbre distant

***git checkout*** : permet de créer une branche, ou de charger l'abre de la branche existante (locale ou distante) sur l'abre local.
[Moins essentiel

***git revert*** : permet de commit les changements inverses d'un commit précédent

***git diff*** : affiche les modifications induites par un commit

***git blame*** : permet de lister les auteurs de modifications sur un fichier

# Partie technique : la pratique

## Les commandes console 

 il est souvent plus efficace d'utiliser une interface graphique pour manipuler git sans erreur, laquelle permet de connaitre de maniere instantanée et dynamique les résultats des commandes git status et git fetch, soit l'état de l'abre local et de l'abre distant sous forme graphique et non textuelle. De plus, ça permet de naviguer plus facilement dans les branches et les différences entre les commits. 

## Les conflits

Les conflits sur git, c'est pas une fatalité, c'est une perte de temps liée a une mauvaise utilisation du logiciel.
Ca arrive quand on merge une branche sur une autre branche qui porte un élément modifié sur chacune des deux entre temps. 
La réponse la plus simple, mais pas forcément la meilleure c'est : 

```

on pull avant de push, du coup le premier a push est le moins embêté. 

```

C'est vrai, mais ça pose deux problèmes, le plus rapide n'a pas nécessairement le meilleur code, et une personne a bossé pour rien. 
Une bonne réaction est de créer des branches "fonctionnelles", qui correspondent chacune à une fonctionnalité métier, et de se les répartir afin d'éviter les conflits de fichiers dans la majorité des cas. 

Le meilleur moyen d'éviter les conflits et de communiquer régulièrement avec son équipe afin d'être conscient de qui travaille sur quelle fonctionnalité et quelle branche. Ainsi vous pourrez trouver un propre petit coin calme ou personne ne vient écraser votre code et ou vous n'écrasez le code de personne : 
vous pouvez travailler sans vous soucier des conflits éventuels.

## La qualité et les pull requests

Git est un outil de gestion de version décentralisé, et donc par nature collaboratif. Il offre une fonctionnalité qui complète à mon sens très bien les notions que l'on vient d'aborder.
Quand un développeur, sur sa branche, vient de finir une fonctionnalité, que tout est parfait pour lui, il a des tests, de la doc etc, il peut alors faire une pull request depuis le site web de son hébergeur git. 
Une pull request c'est un mail qui part chez tous les collaborateurs, et un lien qui leur permet de lire les modifications de tous les commits sur la branche. Ainsi, on diminue énormément les chances de faire passer une erreur, une incompréhension sur la branche master, et ainsi on économise de précieuses heures de débug tout en mettant au courant l'équipe de son avancement.
La pull request est validée, ou commentée et invalidée par chaque collaborateur, et sera mergée sur la branche principale après l'approbation de tous.

# Pourquoi c'est bien

Pour l'emploi : Mettez vous à la place d'un employeur, vous avez deux candidats potentiels avec les mêmes capacités techniques a priori dans 3 techno utilisées dans votre entreprise. L'un a un git avec 5 projets utilisants les technlogies en question, l'autre un CV. Dans un cas, l'évaluation du niveau du candidat est fiable est disponible dans un cas, subjective dans l'autre. 

Le travail en groupe est inalienable a la condition de développeur si on est pas freelance : Actuellement, git est extrèmement utilisé du fait de sa gratuité, de son efficacité et de sa simlicité relative d'utilisation relativement aux deux points précédents. 

Automatisation des tests : dans les grosses structures et pour les projets bien mis en place, on retrouve fréquemment es mécanismes d'intégration continue, en particulier dans l'open source et les projets de grande envergure, par exemple linux ou mozilla. L'automatisation de test à chaque merge et l'utilisation de pull request permet d'intégrer uniquement le code validé par les tests en provenance de tout contributeur.

Efficacité du travail de groupe : Dans un système d'information, la rapidité de transmission de l'information est directement proportionnelle à l'efficacité du de ce système d'information.
En vérité une équipe c'est un système d'information, et git est un outil qui permet de transmettre instantanément des fichiers cohérents à une ou plusieurs personne et réciproquement, et donc une forte plusvalue dans l'efficacité d'un groupe.

# Conclusion

En conclusion je dirai simplement que je n'ai fait aucune mention de quelconques reset -f (ni de -f tout court), c'est pour deux bonnes raisons : car à part situation très particulières on peut faire toute opération pour récupérer des changements préalables avec les commandes citées précedemment, et car git est un gestionnaire de version, on a a priori pas de raison d'en supprimer du contenu, et toute action destructive peut comprommettre l'accés à certaines versions. 
